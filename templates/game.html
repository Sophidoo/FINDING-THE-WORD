{% extends "base.html" %}
{% block title %}Find the Word - Dashboard{% endblock %}


{% block content %}
<div class="dashboard-container">


    <!-- Dashboard Header/Navbar -->
    <header class="dashboard-header">
        <div class="navbar-left">
            <div class="dashboard-logo">
                <div class="logo-box">F</div>
                <h1 class="dashboard-title">FIND THE WORD</h1>
            </div>
            <button class="mobile-menu-btn" id="mobileMenuBtn" aria-label="Toggle menu">‚ò∞</button>
            <nav class="navbar-links" id="navbarLinks">
                <a href="/game" class="nav-link active">Game</a>
                <a href="/leaderboard" class="nav-link">Leaderboard</a>
                <a href="/contact" class="nav-link">Contact Us</a>
            </nav>
        </div>
        <div class="navbar-right" id="navbarRight">
            <button id="playNowBtn" class="play-now-btn">PLAY NOW</button>
            <div class="user-info" id="userInfoBtn">
                <div class="user-avatar" id="playerLogo">P</div>
                <span class="user-name" id="playUsername">Player</span>
            </div>
        </div>
    </header>

    <!-- Player Stats (Visible before game) -->
    <div id="playerStatsSection" class="player-stats-section">
        <div class="player-stats-card horizontal">
            <div class="player-stats-header">
                <div class="player-avatar-large">{{ current_user.username[0].upper() if current_user.is_authenticated else 'P' }}</div>
                <div class="player-info-large">
                    <h3 id="playerUsername">{{ current_user.username if current_user.is_authenticated else 'Guest' }}</h3>
                    <p class="player-rank-badge">Rank #<span id="playerRank"></span></p>
                </div>
            </div>
            <div class="stats-grid horizontal">
                <div class="stat-box"><div class="stat-box-value" id="totalGames">0</div><div class="stat-box-label">Total Games</div></div>
                <div class="stat-box"><div class="stat-box-value" id="completedGames">0</div><div class="stat-box-label">Completed</div></div>
                <div class="stat-box"><div class="stat-box-value" id="bestScore">0</div><div class="stat-box-label">Best Score</div></div>
                <div class="stat-box"><div class="stat-box-value" id="avgScore">0</div><div class="stat-box-label">Total Points</div></div>
            </div>
            <div class="completion-rate horizontal">
                <div class="completion-rate-label">
                    <span>Completion Rate</span>
                    <span id="completionRatePercent">0%</span>
                </div>
                <div class="completion-rate-bar">
                    <div class="completion-rate-fill" id="completionRateFill" style="width: 0%"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Game Area -->
    <div id="gameArea" class="hidden">
        <div class="game-layout">
            <div class="game-panel">
                <div class="game-controls">
                    <div class="difficulty-selector">
                        <button class="difficulty-btn easy" data-difficulty="1">Easy</button>
                        <button class="difficulty-btn medium" data-difficulty="2">Medium</button>
                        <button class="difficulty-btn hard" data-difficulty="3">Hard</button>
                    </div>
                    <div class="game-actions">
                        <button class="action-btn primary" id="newGameBtn">New Game</button>
                        <button class="action-btn danger" id="endGameBtn">End Game</button>
                    </div>
                </div>

                <div class="word-grid-container">
                    <div class="word-grid easy" id="wordGrid"></div>
                </div>

                <div class="words-to-find">
                    <h3>Words to Find</h3>
                    <div class="words-list" id="wordsList"></div>
                </div>
            </div>

            <aside class="side-panel">
                <div class="stats-card">
                    <h3>Game Stats</h3>
                    <div class="stat-item"><span class="stat-label">Time</span><span class="stat-value timer" id="timer">00:00</span></div>
                    <div class="stat-item"><span class="stat-label">Score</span><span class="stat-value score" id="score">0</span></div>
                    <div class="stat-item"><span class="stat-label">Found</span><span class="stat-value" id="foundCount">0/0</span></div>
                    <div class="progress-container">
                        <div class="progress-label"><span>Progress</span><span id="progressPercent">0%</span></div>
                        <div class="progress-bar"><div class="progress-fill" id="progressFill" style="width: 0%"></div></div>
                    </div>
                </div>

                <div class="achievements-card">
                    <h3>Word Information</h3>
                    <div id="wordInfoContent">
                        <p style="text-align:center;color:#aaa;padding:2rem 1rem;">Select a word to see details!</p>
                    </div>
                    <button class="hint-btn" id="hintBtn">Use Hint</button>
                    <span class="hint-count">Hints: <span id="hintCount">3</span></span>
                </div>
            </aside>
        </div>
    </div>

    <!-- Achievements Section (Always Visible) -->
    <section class="dashboard-achievements-section" id="achievementSection">
        <div class="achievements-header">
            <h2>üèÜ ACHIEVEMENTS</h2>
            <button class="view-leaderboard-btn" onclick="window.location.href='leaderboard'">VIEW LEADERBOARD</button>
        </div>
        <div class="dashboard-achievements-grid" id="dashboardAchievementsGrid">
            <!-- Achievements will be dynamically generated by JavaScript -->
        </div>
    </section>
</div>

<!-- Achievement Unlock Notification -->
<div id="achievementNotification" class="achievement-notification">
    <div class="achievement-notification-content">
        <div class="achievement-notification-icon" id="achievementNotificationIcon">üèÜ</div>
        <div class="achievement-notification-text">
            <div class="achievement-notification-title">ACHIEVEMENT UNLOCKED!</div>
            <div class="achievement-notification-name" id="achievementNotificationName">Achievement Name</div>
        </div>
    </div>
</div>

<!-- Game Completion Modal -->
<div id="gameCompletionModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 id="modalTitle">üéâ CONGRATULATIONS! üéâ</h2>
        </div>
        <div class="modal-body">
            <p id="modalMessage" class="modal-message"></p>
            <div class="stats-display">
                <div class="stat-row">
                    <span class="stat-label">üèÜ Score:</span>
                    <span class="stat-value" id="modalScore">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üìù Total Words:</span>
                    <span class="stat-value" id="modalTotalWords">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">‚úì Words Found:</span>
                    <span class="stat-value" id="modalWordsFound">0</span>
                </div>
                <div class="stat-row" id="missedWordsRow">
                    <span class="stat-label">‚è±Ô∏è Time Taken:</span>
                    <span class="stat-value" id="modalTimeTaken">0</span>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="modal-btn" id="viewLeaderboardBtn">View Leaderboard</button>
            <button class="modal-btn" id="closeCompletionModal">Close</button>
        </div>
    </div>
</div>

<!-- End Game Confirmation Modal -->
<div id="endGameModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>‚ö†Ô∏è End Game</h2>
        </div>
        <div class="modal-body">
            <p class="modal-message">Are you sure you want to end the game?</p>
            <p class="modal-submessage">Your progress will be lost.</p>
        </div>
        <div class="modal-footer">
            <button class="modal-btn cancel" id="cancelEndGame">No, Keep Playing</button>
            <button class="modal-btn danger" id="confirmEndGame">Yes, End Game</button>
        </div>
    </div>
</div>

<!-- Notification -->
<div id="notificationAlert" class="notification-alert"><span id="notificationMessage"></span></div>

{% endblock %}

{% block scripts %}
<script>
    let currentGame = null;
    let timerInterval = null;
    let seconds = 0;
    let hintsUsed = 0;
    let timeRemaining = 0;
    let gameState = 'idle';
    let timerEl = null;

    async function apiCall(url, options = {}) {
        const res = await fetch(url, {
            method: options.method || 'GET',
            headers: { 'Content-Type': 'application/json' },
            body: options.body,
            credentials: 'include'
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.message || 'Error');
        return data;
    }
    // === LOAD PLAYER STATS FROM BACKEND ===
    async function loadPlayerStats() {
        try {
            const stats = await apiCall('/api/leaderboard/user-stats');
            console.log(stats)
            // Update all the fields
            document.getElementById('playerUsername').textContent = stats.username || 'Guest';
            document.getElementById('playUsername').textContent = stats.username || 'Guest';
            document.getElementById('playerLogo').textContent = stats.username.trim().charAt(0).toUpperCase() || 'P';
            document.getElementById('totalGames').textContent = stats.total_games;
            document.getElementById('completedGames').textContent = stats.completed_games;
            document.getElementById('playerRank').textContent = stats.rank;

            // Best score overall (from any level)
            const bestOverall = Math.max(
                stats.best_scores[1]?.score || 0,
                stats.best_scores[2]?.score || 0,
                stats.best_scores[3]?.score || 0
            );
            document.getElementById('bestScore').textContent = bestOverall;

            document.getElementById('avgScore').textContent = Math.round(stats.total_score);

            // Completion rate
            const completionRate = stats.completion_rate.replace('%', '');
            document.getElementById('completionRatePercent').textContent = stats.completion_rate;
            document.getElementById('completionRateFill').style.width = completionRate + '%';


        } catch (err) {
            console.error('Failed to load player stats:', err);
            // Keep defaults (0s) if offline or error
        }
    }
    async function showGameCompletionModal() {
        if (!currentGame) return;

        try {
            // Call the end game API to get final accurate stats
            const result = await apiCall('/api/game/end', {
                method: 'POST',
                body: JSON.stringify({ session_id: currentGame.session_id })
            });
            console.log(result)

            // Format time_taken (assuming it's in seconds)
            const mins = String(Math.floor(result.time_taken / 60)).padStart(2, '0');
            const secs = String(result.time_taken % 60).padStart(2, '0');
            const timeFormatted = `${mins}:${secs}`;

            // Update modal with real backend data
            document.getElementById('modalTitle').textContent = 'CONGRATULATIONS!';
            document.getElementById('modalMessage').textContent = result.message || 'You completed the game!';

            document.getElementById('modalScore').textContent = result.final_score;
            document.getElementById('modalTotalWords').textContent = result.total_words;
            document.getElementById('modalWordsFound').textContent = result.words_found;
            document.getElementById('modalCompletionRate').textContent = result.completion_rate;
            document.getElementById('modalTimeTaken').textContent = result.time_taken;

            // Finally show the modal
            document.getElementById('gameCompletionModal').classList.add('show');

            // Important: Mark game as ended so we don't call /end twice
            currentGame = null;

        } catch (err) {
            showNotification('Error saving score: ' + err.message);
            console.error(err);
            // Still show a basic modal even if API fails
            document.getElementById('modalMessage').textContent = 'You won! (Score may not be saved)';
            document.getElementById('gameCompletionModal').classList.add('show');
        }
    }

    function showEndGameConfirmation() {
        document.getElementById('endGameModal').classList.add('show');
    }

    // === UPDATED endGame (only called when player confirms or quits) ===
    function endGame() {
        if (timerInterval) clearInterval(timerInterval);
        timerInterval = null;
        currentGame = null;
        gameState = 'idle';

        document.getElementById('gameArea').classList.add('hidden');
        document.getElementById('playerStatsSection').style.display = 'block';

        const achievementSection = document.getElementById('achievementSection');
        if (achievementSection) achievementSection.style.display = 'block';

        loadPlayerStats();
        renderDashboardAchievements();
    }
    function clearGridSelection() {
        document.querySelectorAll('.grid-cell.selected, .grid-cell.found').forEach(cell => {
            cell.classList.remove('selected');
        });
    }
    function playNow() {
        gameState = 'choosing-difficulty';

        document.getElementById('gameArea').classList.remove('hidden');
        document.getElementById('playerStatsSection').style.display = 'none';

        // Hide achievement section if it exists
        const achievementSection = document.getElementById('achievementSection');
        if (achievementSection) achievementSection.style.display = 'none';

        // Show difficulty selector, hide "End Game" button
        document.querySelector('.difficulty-selector').style.display = 'flex';
        document.getElementById('endGameBtn').style.display = 'none';
        document.getElementById('newGameBtn').textContent = 'New Game'; // make sure it says "New Game"

        // Clear any old grid
        document.getElementById('wordGrid').innerHTML = '';
        document.getElementById('wordsList').innerHTML = '';
        document.getElementById('timer').textContent = '00:00';
        document.getElementById('score').textContent = '0';
        document.getElementById('foundCount').textContent = '0/0';
        document.getElementById('progressFill').style.width = '0%';
        document.getElementById('progressPercent').textContent = '0%';
    }
    async function startGame() {
        if (gameState !== 'choosing-difficulty' && gameState !== 'playing') {
            showNotification('Click "PLAY NOW" first!');
            return;
        }

        const levelBtn = document.querySelector('.difficulty-btn.active');
        if (!levelBtn) {
            showNotification('Please select a difficulty level first!');
            return;
        }

        const level = levelBtn.dataset.difficulty;

        try {
            const game = await apiCall('/api/game/start', {
                method: 'POST',
                body: JSON.stringify({ level_id: parseInt(level) })
            });

            // Success! Now we're really playing
            currentGame = game;
            gameState = 'playing';
            console.log(game)

            // UI Changes when game actually starts
            document.querySelector('.difficulty-selector').style.display = 'none';   // Hide difficulty buttons
            document.getElementById('endGameBtn').style.display = 'inline-block';   // Show End Game
            document.getElementById('newGameBtn').textContent = 'New Game';         // Optional: keep or change

            renderGrid(game.grid);
            renderWordList(game.words);
            startTimer();
            updateStats(0, game.total_words);
            hintsUsed = 0;
            document.getElementById('hintCount').textContent = '3';
            document.getElementById('score').textContent = '0';

            showNotification(`Game started! Find all words!`);

        } catch (err) {
            showNotification('Failed to start game: ' + err.message);
        }
    }

    function renderGrid(grid) {
        const container = document.getElementById('wordGrid');
        container.innerHTML = '';
        container.className = `word-grid ${grid.length === 8 ? 'easy' : grid.length === 10 ? 'medium' : 'hard'}`;
        grid.forEach((row, y) => {
            row.forEach((letter, x) => {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.textContent = letter;
                cell.dataset.x = x;
                cell.dataset.y = y;
                container.appendChild(cell);
            });
        });
    }



    function renderWordList(words) {
        const list = document.getElementById('wordsList');
        list.innerHTML = '';

        words.forEach(wordData => {
            const item = document.createElement('div');
            item.className = 'word-item';
            item.textContent = wordData;           // e.g., "ELEPHANT"
            item.id = `word-${wordData}`;       // This is the DB ID!
            item.style.cursor = 'pointer';              // Make it look clickable
            item.title = 'Click for word details';

            // Click handler ‚Äî show word info
            item.addEventListener('click', () => showWordDetails(wordData));

            list.appendChild(item);
        });
    }

    async function showWordDetails(wordData) {
        const container = document.getElementById('wordInfoContent');

        // Show loading state
        container.innerHTML = `
            <div style="text-align:center;padding:2rem;color:#888;">
                <p>Loading word details...</p>
            </div>
        `;

        try {
            const word = await apiCall(`/api/words/search?word=${wordData}`);

            // Beautiful display
            container.innerHTML = `
                <div class="word-info-display">
                    <h3 style="margin:0 0 0.5rem 0;color:#00d4ff;font-size:1.4rem;">
                        ${word.word}
                    </h3>
                    <p style="margin:0.5rem 0;font-style:italic;color:#aaa;">
                        (${word.length} letters ‚Ä¢ ${word.difficulty} ‚Ä¢ ${word.category})
                    </p>
                    <hr style="border:0;border-top:1px solid #444;margin:1rem 0;">
                    <p style="line-height:1.6;color:#ddd;">
                        <strong>Definition:</strong><br>
                        ${word.definition || '<em>No definition available</em>'}
                    </p>
                    ${word.example ? `
                        <p style="margin-top:1rem;color:#ddd;">
                            <strong>Example:</strong> "${word.example}"
                        </p>
                    ` : ''}
                    ${word.trivia ? `
                        <p style="margin-top:1rem;color:#ddd;">
                            <strong>Do you know:</strong> "${word.trivia}"
                        </p>
                    ` : ''}
                </div>
            `;

        } catch (err) {
            console.error('Failed to load word:', err);
            container.innerHTML = `
                <p style="text-align:center;color:#e74c3c;padding:2rem;">
                    Failed to load word details.
                </p>
            `;
        }
    }

    function markWordFound(word) {
        const el = document.getElementById(`word-${word}`);
        if (el) el.classList.add('found');
    }

    function updateStats(found, total) {
        document.getElementById('foundCount').textContent = `${found}/${total}`;
        const progress = total > 0 ? (found / total) * 100 : 0;
        document.getElementById('progressFill').style.width = progress + '%';
        document.getElementById('progressPercent').textContent = Math.round(progress) + '%';

        // Pure 100 points per word
        document.getElementById('score').textContent = (found * 100);
    }

      // Add this global variable at the top with others

function startTimer() {
    if (!currentGame?.time_limit) return;

    timeRemaining = currentGame.time_limit;

    if (timerInterval) clearInterval(timerInterval);

    updateTimerDisplay();

    timerInterval = setInterval(async () => {
        timeRemaining--;
        updateTimerDisplay();

        if (timeRemaining <= 0) {
            clearInterval(timerInterval);
            document.getElementById('timer').textContent = "00:00";
            timerEl.style.color = '#e74c3c';

            // TIME'S UP ‚Äî GAME OVER!
            showNotification("Time's Up! Game Over");

            try {
                // Still end the session (to save stats), but show correct message
                const result = await apiCall('/api/game/end', {
                    method: 'POST',
                    body: JSON.stringify({ session_id: currentGame.session_id })
                });

                // Show "Game Over" modal instead of "Congratulations"
                document.getElementById('modalTitle').textContent = 'Time‚Äôs Up!';
                document.getElementById('modalMessage').innerHTML = `
                    <p style="font-size:1.2rem;color:#fff;">
                        You ran out of time!
                    </p>
                    <p style="margin:1rem 0;color:#ff6b6b;">
                        You found <strong>${result.words_found}</strong> out of <strong>${result.total_words}</strong> words.
                    </p>
                `;
                document.getElementById('modalScore').textContent = result.final_score;
                document.getElementById('modalTotalWords').textContent = result.total_words;
                document.getElementById('modalWordsFound').textContent = result.words_found;
                document.getElementById('modalTimeTaken').textContent = result.time_taken;

                document.getElementById('gameCompletionModal').classList.add('show');
                currentGame = null;

            } catch (err) {
                showNotification('Failed to save game');
                document.getElementById('modalTitle').textContent = 'Time‚Äôs Up!';
                document.getElementById('modalMessage').textContent = 'Game over. Score not saved.';
                document.getElementById('gameCompletionModal').classList.add('show');
            }
        }
    }, 1000);
}

function updateTimerDisplay() {
    if (!timerEl) timerEl = document.getElementById('timer');
    const mins = String(Math.floor(timeRemaining / 60)).padStart(2, '0');
    const secs = String(timeRemaining % 60).padStart(2, '0');
    timerEl.textContent = `${mins}:${secs}`;

    // Optional: turn red when < 30 seconds
    if (!timerEl) timerEl = document.getElementById('timer');
    if (timeRemaining <= 30) {
        timerEl.style.color = '#e74c3c';
        timerEl.style.fontWeight = 'bold';
    } else {
        timerEl.style.color = '';
        timerEl.style.fontWeight = '';
    }
}

    document.getElementById('hintBtn').onclick = async () => {
        if (!currentGame || hintsUsed >= 3) return showNotification('No hints left!');
        try {
            const hint = await apiCall('/api/game/hint', {
                method: 'POST',
                body: JSON.stringify({ session_id: currentGame.session_id })
            });
            showNotification(`Hint: Starts with "${hint.hint}"`);
            hintsUsed++;
            document.getElementById('hintCount').textContent = 3 - hintsUsed;
        } catch (err) { showNotification(err.message); }
    };

    // Drag selection
    let selecting = false;
    let selected = [];
    const gridContainer = document.getElementById('wordGrid');
    gridContainer.addEventListener('mousedown', e => {
        if (!e.target.classList.contains('grid-cell')) return;
        e.preventDefault(); // Prevent text selection
        startSelection(e.target);
    });

    gridContainer.addEventListener('mousemove', e => {
        if (selecting && e.target.classList.contains('grid-cell')) {
            addToSelection(e.target);
        }
    });

    document.addEventListener('mouseup', () => {
        if (selecting) endSelection();
    });

    // 2. TOUCH EVENTS (Mobile)
    gridContainer.addEventListener('touchstart', e => {
        if (!e.target.classList.contains('grid-cell')) return;
        e.preventDefault(); // Prevent scrolling while selecting
        startSelection(e.target);
    }, { passive: false });

    gridContainer.addEventListener('touchmove', e => {
        if (!selecting) return;
        e.preventDefault(); // Stop screen scrolling
        
        // Get element under the finger
        const touch = e.touches[0];
        const target = document.elementFromPoint(touch.clientX, touch.clientY);
        
        if (target && target.classList.contains('grid-cell')) {
            addToSelection(target);
        }
    }, { passive: false });

    document.addEventListener('touchend', () => {
        if (selecting) endSelection();
    });

    // --- HELPER FUNCTIONS ---
    function startSelection(cell) {
        selecting = true;
        selected = [cell];
        cell.classList.add('selected');
    }
    function addToSelection(cell) {
        // Prevent duplicate selection of the same cell
        if (!selected.includes(cell)) {
            selected.push(cell);
            cell.classList.add('selected');
        }
    }

    function endSelection() {
        selecting = false;
        const word = selected.map(c => c.textContent).join('');
        
        // Basic validation before hitting API
        if (word.length < 3) {
            clearGridSelection();
            selected = [];
            return;
        }
        submitWord(word);
    }

    document.getElementById('wordGrid').addEventListener('mousedown', e => {
        if (!e.target.classList.contains('grid-cell')) return;
        selecting = true;
        selected = [e.target];
        e.target.classList.add('selected');
    });
    document.getElementById('wordGrid').addEventListener('mousemove', e => {
        if (!selecting || !e.target.classList.contains('grid-cell')) return;
        if (!selected.includes(e.target)) {
            selected.push(e.target);
            e.target.classList.add('selected');
        }
    });
    document.addEventListener('mouseup', () => {
        if (!selecting) return;
        selecting = false;
        const word = selected.map(c => c.textContent).join('');
        if (word.length < 3) {
            selected.forEach(c => c.classList.remove('selected'));
            selected = [];
            return;
        }
        submitWord(word);
    });

    async function submitWord(word) {
        try {
            const result = await apiCall('/api/game/validate', {
                method: 'POST',
                body: JSON.stringify({ session_id: currentGame.session_id, word })
            });
            console.log(result)
            if (result.valid && !result.already_found) {
                selected.forEach(c => c.classList.add('found'));
                markWordFound(word);

                // Use backend score (guaranteed correct)
                document.getElementById('score').textContent = result.score;
                updateStats(result.found_count, result.total_words);

                showNotification(`+100! "${word}" found!`);

                if (result.new_achievements && result.new_achievements.length > 0) {
                    result.new_achievements.forEach(ach => {
                        setTimeout(() => {
                            showAchievementNotification(ach);
                        }, index * 2000);
                    });
                    renderDashboardAchievements();
                }

                if (result.found_count === result.total_words) {
                    clearInterval(timerInterval);  // Stop timer
                    setTimeout(async () => {
                        try {
                            const final = await apiCall('/api/game/end', {
                                method: 'POST',
                                body: JSON.stringify({ session_id: currentGame.session_id })
                            });

                            document.getElementById('modalTitle').textContent = 'CONGRATULATIONS!';
                            document.getElementById('modalMessage').textContent = 'You found all the words!';
                            document.getElementById('modalScore').textContent = final.final_score;
                            document.getElementById('modalTotalWords').textContent = final.total_words;
                            document.getElementById('modalWordsFound').textContent = final.words_found;
                            document.getElementById('modalTimeTaken').textContent = final.time_taken;

                            document.getElementById('gameCompletionModal').classList.add('show');
                            currentGame = null;
                        } catch (err) {
                            showNotification('You won! But score may not be saved.');
                        }
                    }, 800);
                }
            } else {
                showNotification(result.already_found ? 'Already found!' : 'Not in list!');
            }
        } catch (err) {
            showNotification('Error: ' + err.message);
        } finally {
            selected.forEach(c => c.classList.remove('selected'));
            selected = [];
        }
    }



    function showNotification(msg) {
        const el = document.getElementById('notificationMessage');
        el.textContent = msg;
        const alert = document.getElementById('notificationAlert');
        alert.classList.add('show');
        setTimeout(() => alert.classList.remove('show'), 4000);
    }

    // Button Events
    document.getElementById('playNowBtn')?.addEventListener('click', playNow);
    document.getElementById('newGameBtn').addEventListener('click', startGame);
    document.getElementById('endGameBtn').addEventListener('click', showEndGameConfirmation);
    document.querySelectorAll('.difficulty-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
        });
    });




    document.querySelectorAll('.modal').forEach(modal => {
        modal.addEventListener('click', (e) => {
            if (e.target === modal) modal.classList.remove('show');
        });
    });

    document.getElementById('closeCompletionModal').addEventListener('click', () => {
        document.getElementById('gameCompletionModal').classList.remove('show');
        endGame();
        loadPlayerStats();
    });

    document.getElementById('viewLeaderboardBtn').addEventListener('click', () => {
        document.getElementById('gameCompletionModal').classList.remove('show');
        endGame();
        window.location.href = 'leaderboard'
    });

    document.getElementById('userInfoBtn').addEventListener('click', () => {
        window.location.href = 'profile';
    });

    document.getElementById('cancelEndGame').addEventListener('click', () => {
        document.getElementById('endGameModal').classList.remove('show');
    });

    document.getElementById('confirmEndGame').addEventListener('click', () => {
        document.getElementById('endGameModal').classList.remove('show');
        endGame();
        showNotification('Game ended');
    });




    async function renderDashboardAchievements() {
        const grid = document.getElementById('dashboardAchievementsGrid');
        if (!grid) return;

        grid.innerHTML = '<p style="color:#aaa;">Loading achievements...</p>';

        try {
            // Fetch from the new API we made in Step 4
            const achievements = await apiCall('/api/achievements/list');

            grid.innerHTML = '';
            achievements.forEach(ach => {
                const unlocked = ach.unlocked;

                const card = document.createElement('div');
                card.className = `dashboard-achievement-card ${unlocked ? 'unlocked' : 'locked'}`;
                card.innerHTML = `
                    <div class="dashboard-achievement-icon ${unlocked ? '' : 'locked'}">${ach.icon}</div>
                    <div class="dashboard-achievement-details">
                        <h3 class="dashboard-achievement-title">${ach.name}</h3>
                        <p class="dashboard-achievement-description">${ach.description}</p>
                        ${unlocked
                            ? '<div class="dashboard-achievement-completed">‚úì UNLOCKED</div>'
                            : '<div class="dashboard-achievement-locked">üîí LOCKED</div>'}
                    </div>
                `;
                grid.appendChild(card);
            });
        } catch (err) {
            console.error(err);
            grid.innerHTML = '<p style="color:red;">Failed to load achievements.</p>';
        }
    }

        // Show achievement unlock notification
        function showAchievementNotification(achievement) {
            const notification = document.getElementById('achievementNotification');
            const iconElement = document.getElementById('achievementNotificationIcon');
            const nameElement = document.getElementById('achievementNotificationName');

            iconElement.textContent = achievement.icon;
            nameElement.textContent = achievement.name;
            notification.classList.add('show');

            setTimeout(() => {
                notification.classList.remove('show');
            }, 4000);
        }


    // Show notifications for newly unlocked achievements
    function notifyNewAchievements(previousStats) {
        const newAchievements = checkNewlyUnlockedAchievements(previousStats, playerStats);
        if (newAchievements.length > 0) {
            showAchievementNotification(newAchievements[0]);
            newAchievements.slice(1).forEach((achievement, index) => {
                setTimeout(() => {
                    showAchievementNotification(achievement);
                }, (index + 1) * 4500);
            });
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        document.querySelector('.difficulty-btn.easy').classList.add('active');
        loadPlayerStats();
        renderDashboardAchievements();


        const mobileMenuBtn = document.getElementById('mobileMenuBtn');
        const navbarLinks = document.getElementById('navbarLinks');
        const navbarRight = document.getElementById('navbarRight');

        if (mobileMenuBtn) {
            mobileMenuBtn.addEventListener('click', () => {
                mobileMenuBtn.classList.toggle('active');
                navbarLinks.classList.toggle('active');
                navbarRight.classList.toggle('active');

                // Update button text
                mobileMenuBtn.textContent = mobileMenuBtn.classList.contains('active') ? '‚úï' : '‚ò∞';
            });
        }

     });

</script>
{% endblock %}